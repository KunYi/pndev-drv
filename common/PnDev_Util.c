/*****************************************************************************/
/*  Copyright (C) 2018 Siemens Aktiengesellschaft. All rights reserved.      */
/*****************************************************************************/
/* This program is free software; you can redistribute it and/or             */
/* modify it under the terms of the GNU General Public License version 2     */
/* as published by the Free Software Foundation; or, when distributed        */
/* separately from the Linux kernel or incorporated into other               */
/* software packages, subject to the following license:                      */
/*                                                                           */
/*  This program is protected by German copyright law and international      */
/*  treaties. The use of this software including but not limited to its      */
/*  Source Code is subject to restrictions as agreed in the license          */
/*  agreement between you and Siemens.                                       */
/*  Copying or distribution is not allowed unless expressly permitted        */
/*  according to your license agreement with Siemens.                        */
/*                                                                           */
/*****************************************************************************/
/*                                                                           */
/*  P r o j e c t         &P: PROFINET IO Runtime Software              :P&  */
/*                                                                           */
/*  P a c k a g e         &W: PROFINET IO Runtime Software              :W&  */
/*                                                                           */
/*  C o m p o n e n t     &C: PnDev_Driver                              :C&  */
/*                                                                           */
/*  F i l e               &F: PnDev_Util.c                              :F&  */
/*                                                                           */
/*  V e r s i o n         &V: BC_PNRUN_P07.01.00.00_00.02.00.05         :V&  */
/*                                                                           */
/*  D a t e  (YYYY-MM-DD) &D: 2018-07-18                                :D&  */
/*                                                                           */
/*****************************************************************************/
//
//  D e s c r i p t i o n:
//
//	Useful routines for using PnDev_Driver
//
//****************************************************************************/

// Note:
//	A "C" module doesn't support precompiled header
//	-> turn it off at ProjectSettings >> C/C++ >> Precompiled Headers of  t h i s  file

#include <precomp.h>														// environment specific IncludeFiles
																			//	- name is fixed for Driver ToolChain, include by conditional compiling not possible!
#include <PnDev_Driver_Inc.h>												// all IncludeFiles of PnDev_Driver
#include <PnDev_Util.h>

//************************************************************************
//  D e s c r i p t i o n :
//
//  initialize PHY connection of Soc1
//************************************************************************

BOOLEAN fnDrvUtil_InitPhySoc1(	volatile UINT8*	pGpioIn,
								volatile UINT8*	pScrbIn,
								const BOOLEAN	bPhyClockExtIn,				// TRUE: PHY clock is generated by external oscillator
								const UINT32	lDimErrorIn,
								PNDEV_CHAR*		sErrorOut)
{
BOOLEAN bResult = FALSE;

	if	(	(pGpioIn == NULL)
		||	(pScrbIn == NULL))
		// invalid ptr
	{
		// set ErrorString
		_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
		_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Invalid pointer!"), _TRUNCATE);
	}
	else
	{
	volatile UINT32* 	pIrteCtrl 				= NULL;
	volatile UINT32*	pPnPb					= NULL;
	volatile UINT32*	pGpioRegPortMode0_L		= NULL;
	volatile UINT32*	pGpioRegPortMode0_H		= NULL;
	volatile UINT32*	pGpioRegPortMode1_L		= NULL;
	volatile UINT32*	pGpioRegPortMode1_H		= NULL;

		// success
		bResult = TRUE;

		pIrteCtrl 			= (volatile UINT32*) (pScrbIn + PNDEV_SOC1_SCRB_REG__IRTE_CTRL);
		pPnPb				= (volatile UINT32*) (pScrbIn + PNDEV_SOC1_SCRB_REG__ENABLE_PN_PB);
		pGpioRegPortMode0_L = (volatile UINT32*) (pGpioIn + PNDEV_SOC1_GPIO_REG__PORT_MODE0_L);
		pGpioRegPortMode0_H = (volatile UINT32*) (pGpioIn + PNDEV_SOC1_GPIO_REG__PORT_MODE0_H);
		pGpioRegPortMode1_L = (volatile UINT32*) (pGpioIn + PNDEV_SOC1_GPIO_REG__PORT_MODE1_L);
		pGpioRegPortMode1_H = (volatile UINT32*) (pGpioIn + PNDEV_SOC1_GPIO_REG__PORT_MODE1_H);

		if	(!bPhyClockExtIn)
			// PHY clock isn't generated by external oscillator
		{
			// enable PHY clock
			*pPnPb &= 0x7;
		}

		// set interface type of PHYs (IRTE channel 0/1/2 in MII mode)
		//	- MII:	4Bit interface to PHY, 0,25*clock=25MHz, clock by MAC (easier, but more lines required)
		//	- RMII:	2Bit interface to PHY, 0,50*clock=50MHz, clock by PHY
		*pIrteCtrl = 0x7;

		// connect PHYs by MII
		{
			// set AltFct1 of GPIO9:8 / GPIO3:0
			//	- PortMode0_L:	AltFct of GPIO15:0 can be set
			//					only the output needs to be set, because all inputs gets the signal parallel
			//					xxxx xxxx xxxx 1010_xxxx xxxx 1010 1010
			//	Signal			GPIO		Fct(=AltFct+1)		Output		Input
			//	MII1_TXD0		0			2					x
			//	MII1_TXD1		1			2					x
			//	MII1_TXD2		2			2					x
			//	MII1_TXD3		3			2					x
			//	MII1_RXD0		4											x
			//	MII1_RXD1		5											x
			//	MII1_RXD2		6											x
			//	MII1_RXD3		7											x
			//	MII1_TX_ER		8			2					x
			//	MII1_TX_EN		9			2					x
			//	MII1_TX_CLK		10											x
			//	MII1_RX_CLK		11											x
			//	MII1_COL		12											x
			//	MII1_RX_ER		13											x
			//	MII1_CRS		14											x
			//	MII1_RX_DV		15											x
			*pGpioRegPortMode0_L |= 0x000a00aa;

			// set AltFct1 of GPIO25:24 / GPIO19:16
			//	- PortMode0_H:	AltFct of GPIO31:16 can be set
			//					only the output needs to be set, because all inputs gets the signal parallel
			//					xxxx xxxx xxxx 1010_xxxx xxxx 1010 1010
			//	Signal			GPIO		Fct(=AltFct+1)		Output		Input
			//	MII2_TXD0		16			2					x
			//	MII2_TXD1		17			2					x
			//	MII2_TXD2		18			2					x
			//	MII2_TXD3		19			2					x
			//	MII2_RXD0		20											x
			//	MII2_RXD1		21											x
			//	MII2_RXD2		22											x
			//	MII2_RXD3		23											x
			//	MII2_TX_ER		24			2					x
			//	MII2_TX_EN		25			2					x
			//	MII2_TX_CLK		26											x
			//	MII2_RX_CLK		27											x
			//	MII2_COL		28											x
			//	MII2_RX_ER		29											x
			//	MII2_CRS		30											x
			//	MII2_RX_DV		31											x
			*pGpioRegPortMode0_H |= 0x000a00aa;

			// set AltFct1 of GPIO41:40 / GPIO35:32
			//	- PortMode1_L:	AltFct of GPIO47:32 can be set
			//					only the output needs to be set, because all inputs gets the signal parallel
			//					xxxx xxxx xxxx 1010_xxxx xxxx 1010 1010
			//	Signal			GPIO		Fct(=AltFct+1)		Output		Input
			//	MII3_TXD0		32			2					x
			//	MII3_TXD1		33			2					x
			//	MII3_TXD2		34			2					x
			//	MII3_TXD3		35			2					x
			//	MII3_RXD0		36											x
			//	MII3_RXD1		37											x
			//	MII3_RXD2		38											x
			//	MII3_RXD3		39											x
			//	MII3_TX_ER		40			2					x
			//	MII3_TX_EN		41			2					x
			//	MII3_TX_CLK		42											x
			//	MII3_RX_CLK		43											x
			//	MII3_COL		44											x
			//	MII3_RX_ER		45											x
			//	MII3_CRS		46											x
			//	MII3_RX_DV		47											x
			*pGpioRegPortMode1_L |= 0x000a00aa;
		}

		// connect SMI (Serial Management Interface)
		//	- MDC: clock
		//	- MDIO control of ManagementData
		{
			// set AltFct0 of GPIO50:48
			//	- PortMode1_H:	AltFct of GPIO63:48 can be set
			//					xxxx xxxx xxxx xxxx_xxxx xxxx xx01 0101
			//	Signal			GPIO		Fct(=AltFct+1)		Output		Input
			//	MII_MD_DAT		48			1					x
			//	MII_MD_CLK		49			1					x
			//	RES_PHY_N		50			1					x
			*pGpioRegPortMode1_H |= 0x00000015;
		}
	}

	return(bResult);
}

//************************************************************************
//  D e s c r i p t i o n :
//
//  clean up
//************************************************************************

BOOLEAN fnDrvUtil_CleanUp(	uPNDEV_DRIVER_DESC*		hDriverIn,
							const UINT32			lDimArrayIn,
							uPNDEV_OPEN_DEVICE_OUT	uArrayUsedDeviceIn[],	// array=ptr
							BOOLEAN					bCloseAnywayIn,
							const UINT32			lDimErrorIn,
							PNDEV_CHAR*				sErrorOut)
{
BOOLEAN			bResult			= FALSE;
BOOLEAN			bResultClose	= FALSE;
ePNDEV_RESULT	eResult			= ePNDEV_FATAL;
UINT32			i = 0;

	// preset
	bResultClose = TRUE;

	for	(i = 0; i < lDimArrayIn; i++)
		// all entries of UsedDeviceList
	{
	uPNDEV_OPEN_DEVICE_OUT* pEntryTmp = NULL;

		pEntryTmp = &uArrayUsedDeviceIn[i];

		if	(pEntryTmp->uDevice.hHandle != NULL)
			// device opened
		{
		uPNDEV_CLOSE_DEVICE_IN	uCloseDeviceIn;
		uPNDEV_CLOSE_DEVICE_OUT	uCloseDeviceOut;

			_tprintf(	_TEXT("\n---- [%s] PnDev_Driver: Service CloseDevice...(Index=%u)\n"),
						pEntryTmp->sPciLocShort,
						i);

			// set InputParameter
			{
				memset(	&uCloseDeviceIn,
						0,
						sizeof(uPNDEV_CLOSE_DEVICE_IN));

				uCloseDeviceIn.uDevice.hHandle	= pEntryTmp->uDevice.hHandle;
				uCloseDeviceIn.bDoAnyway		= bCloseAnywayIn;

				_tcscpy_s(	uCloseDeviceIn.sDriverTarget,
							_countof(uCloseDeviceIn.sDriverTarget),
							_TEXT(""));
			}

			// close device
			eResult = (*hDriverIn->uIf.pFnCloseDevice)(	hDriverIn,
														sizeof(uPNDEV_CLOSE_DEVICE_IN),
														sizeof(uPNDEV_CLOSE_DEVICE_OUT),
														&uCloseDeviceIn,
														&uCloseDeviceOut);

			if	(eResult != ePNDEV_OK)
				// error
			{
				bResultClose = FALSE;

				// set ErrorString
				_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
				_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): "),			_TRUNCATE);
				_tcsncat_s(	sErrorOut, lDimErrorIn, uCloseDeviceOut.sError,	_TRUNCATE);

				// leave loop
				break;
			}
			else
			{
				_tprintf(_TEXT("Service CloseDevice done.\n\n"));

				if	(!fnDrvUtil_ReleaseListIndex(	i,
													lDimArrayIn,
													uArrayUsedDeviceIn,
													lDimErrorIn,
													sErrorOut))
					// error at releasing used index at UsedDeviceList
				{
					bResultClose = FALSE;

					// leave loop
					break;
				}
			}
		}
	}

	if	(bResultClose)
		// success
	{
		// success
		bResult = TRUE;
	}

	return(bResult);
}

//************************************************************************
//  D e s c r i p t i o n :
//
//  get first free index at UsedDeviceList
//************************************************************************

BOOLEAN fnDrvUtil_GetFreeListIndex(	const UINT32			lDimArrayIn,
									uPNDEV_OPEN_DEVICE_OUT	uArrayUsedDeviceIn[],	// array=ptr
									const UINT32			lDimErrorIn,
									UINT32*					pIndexOut,
									PNDEV_CHAR*				sErrorOut)
{
BOOLEAN	bResult	= FALSE;
UINT32	i		= 0;

	// preset OutputParameter
	{
		*pIndexOut = MAXUINT32;

		_tcscpy_s(	sErrorOut,
					lDimErrorIn,
					_TEXT(""));
	}

	for	(i = 0; i < lDimArrayIn; i++)
		// all entries of UsedDeviceList
	{
	uPNDEV_OPEN_DEVICE_OUT* pEntryTmp = NULL;

		pEntryTmp = &uArrayUsedDeviceIn[i];

		if	(pEntryTmp->uDevice.hHandle == NULL)
			// free entry
		{
			// success
			bResult = TRUE;

			// return
			*pIndexOut = i;

			// leave loop
			break;
		}
	}

	if	(!bResult)
		// error
	{
		// set ErrorString
		_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
		_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): No free entry!"), _TRUNCATE);
	}

	return(bResult);
}

//************************************************************************
//  D e s c r i p t i o n :
//
//  release used index at UsedDeviceList
//************************************************************************

BOOLEAN fnDrvUtil_ReleaseListIndex(	const UINT32			lIndexIn,
									const UINT32			lDimArrayIn,
									uPNDEV_OPEN_DEVICE_OUT	uArrayUsedDeviceIn[],	// array=ptr
									const UINT32			lDimErrorIn,
									PNDEV_CHAR*				sErrorOut)
{
BOOLEAN bResult = FALSE;

	if	(lIndexIn >= lDimArrayIn)
		// invalid index
	{
		// set ErrorString
		_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
		_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Invalid index!"), _TRUNCATE);
	}
	else
	{
		// success
		bResult = TRUE;

		memset(	&uArrayUsedDeviceIn[lIndexIn],
				0,
				sizeof(uPNDEV_OPEN_DEVICE_OUT));
	}

	return(bResult);
}

//************************************************************************
//  D e s c r i p t i o n :
//
//  get index of opened device at UsedDeviceList
//************************************************************************

BOOLEAN fnDrvUtil_GetUsedListIndex(	PNDEV_CHAR*				sPciLocIn,
									const UINT32			lDimArrayIn,
									uPNDEV_OPEN_DEVICE_OUT	uArrayUsedDeviceIn[],	// array=ptr
									UINT32*					pIndexOut)
{
BOOLEAN	bResult	= FALSE;
UINT32	i		= 0;

	// preset OutputParameter
	*pIndexOut = MAXUINT32;

	for	(i = 0; i < lDimArrayIn; i++)
		// all entries of UsedDeviceList
	{
	uPNDEV_OPEN_DEVICE_OUT* pEntryTmp = NULL;

		pEntryTmp = &uArrayUsedDeviceIn[i];

		if	(_tcscmp(pEntryTmp->sPciLoc, sPciLocIn) == 0)
			// device in use
		{
			// success
			bResult = TRUE;

			// return
			*pIndexOut = i;

			// leave loop
			break;
		}
	}

	return(bResult);
}

//************************************************************************
//  D e s c r i p t i o n :
//
//  set current directory for the current process to path of EXE-file
//************************************************************************

//------------------------------------------------------------------------
#if defined (PNDEV_OS_WIN)
//------------------------------------------------------------------------
BOOLEAN fnDrvUtil_SetCurDirToExe(	PNDEV_CHAR*		sFullPathExeIn,
									const UINT32	lDimErrorIn,
									PNDEV_CHAR*		sErrorOut)
{
BOOLEAN		bResult	= FALSE;
PNDEV_CHAR*	pDest	= NULL;
PNDEV_CHAR	sPathTmp[PNDEV_SIZE_STRING_BUF] = {0};

	// search backwards for last '\'
	//	- after '\' there is the EXE-FileName
	pDest = _tcsrchr( sFullPathExeIn, '\\');

	if	(pDest == NULL)
		// error
	{
		// set ErrorString
		_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
		_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Invalid path of EXE-file!"), _TRUNCATE);
	}
	else
	{
	size_t		lPos = 0;
	PNDEV_CHAR	sPathExe[PNDEV_SIZE_STRING_BUF] = {0};

		// get position of last '\' (subtraction of ptr: pDest-pStart)
		lPos = (size_t) (pDest - sFullPathExeIn);

		// Note:
		//	- standard implementation of strncpy()/wcsncpy() does not add a terminal NULL -> preset buffer with '\0'
		//	- adding '\0' is difficult if _TRUNCATE is used
		memset(	sPathExe,
				0,
				sizeof(sPathExe));

		// get path of EXE-file (inclusive last '\')
		_tcsncpy_s(	sPathExe,
					_countof(sPathExe),
					sFullPathExeIn,
					(lPos+1));

		// for debug purpose
		GetCurrentDirectory(_countof(sPathTmp),
							sPathTmp);

		if	(!SetCurrentDirectory(sPathExe))
			// error at setting current directory
		{
			// set ErrorString
			_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
			_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Error at setting current directory!"), _TRUNCATE);
		}
		else
		{
			// success
			bResult = TRUE;

			// for debug purpose
			GetCurrentDirectory(_countof(sPathTmp), sPathTmp);
		}
	}

	return(bResult);
}

//------------------------------------------------------------------------
#elif defined (PNDEV_OS_ADONIS)
//------------------------------------------------------------------------
BOOLEAN fnDrvUtil_SetCurDirToExe(	PNDEV_CHAR*		sFullPathExeIn,
									const UINT32	lDimErrorIn,
									PNDEV_CHAR*		sErrorOut)
{
	return(TRUE);
}
//------------------------------------------------------------------------
#elif defined (PNDEV_OS_LINUX)
//------------------------------------------------------------------------
BOOLEAN fnDrvUtil_SetCurDirToExe( PNDEV_CHAR*   sFullPathExeIn,
                  	  	  	  	  const UINT32  lDimErrorIn,
                  	  	  	  	  PNDEV_CHAR*   sErrorOut)
{
BOOLEAN   	bResult = FALSE;
PNDEV_CHAR* pDest = NULL;
PNDEV_CHAR  sPathTmp[PNDEV_SIZE_STRING_BUF] = {0};

		UNREFERENCED_PARAMETER(sFullPathExeIn);

	  if(readlink("/proc/self/exe", sPathTmp, PNDEV_SIZE_STRING_BUF) == -1)
		// error at getting Path of executable
	  {
		// set ErrorString
		_tcscpy_s(  sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
		_tcsncat_s( sErrorOut, lDimErrorIn, _TEXT("(): path of EXE-file not found!"), _TRUNCATE);

	  }

	  // search backwards for last '/'
	  //  - after '/' there is the EXE-FileName
	  pDest = _tcsrchr( sPathTmp, '/');

	  if  (pDest == NULL)
		// error
	  {
		// set ErrorString
		_tcscpy_s(  sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
		_tcsncat_s( sErrorOut, lDimErrorIn, _TEXT("(): Invalid path of EXE-file!"), _TRUNCATE);
	  }
	  else
	  {
	  size_t    lPos = 0;
	  PNDEV_CHAR  sPathExe[PNDEV_SIZE_STRING_BUF] = {0};

		// get position of last '\' (subtraction of ptr: pDest-pStart)
		lPos = pDest - sPathTmp;

		// Note:
		//  - standard implementation of strncpy()/wcsncpy() does not add a terminal NULL -> preset buffer with '\0'
		//  - adding '\0' is difficult if _TRUNCATE is used
		memset( sPathExe,
			0,
			sizeof(sPathExe));

		// get path of EXE-file (inclusive last '\')
		_tcsncpy_s( sPathExe,
			  _countof(sPathExe),
			  sPathTmp,
			  (lPos+1));

		// for debug purpose
		getcwd(sPathTmp, _countof(sPathTmp));

		if  (chdir(sPathExe) != 0)
		  // error at setting current directory
		{
		  // set ErrorString
		  _tcscpy_s(  sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
		  _tcsncat_s( sErrorOut, lDimErrorIn, _TEXT("(): Error at setting current directory!"), _TRUNCATE);
		}
		else
		{
		  // success
		  bResult = TRUE;

		  // for debug purpose
		  getcwd(sPathTmp, _countof(sPathTmp));
		}
	  }

	  return(bResult);
}
//------------------------------------------------------------------------
#else
//------------------------------------------------------------------------
#endif

//************************************************************************
//  D e s c r i p t i o n :
//
//	register StdStreams (stdin, stdout, stderr)
//
//	Note:
//	- stdout/stderr use the same stream
//************************************************************************

//------------------------------------------------------------------------
#if defined (PNDEV_OS_WIN) || defined (PNDEV_OS_LINUX)
//------------------------------------------------------------------------
BOOLEAN	fnDrvUtil_RegisterStdStreams(	const ePNDEV_STDIN	eStdinIn,
										const ePNDEV_STDOUT	eStdoutIn,
										const UINT32		lDimErrorIn,
										HANDLE*				pHandleStdinOut,
										HANDLE*				pHandleStdoutOut,
										PNDEV_CHAR*			sErrorOut)
{
BOOLEAN bResult = FALSE;

	// preset OutputParameter
	{
		*pHandleStdinOut	= NULL;
		*pHandleStdoutOut	= NULL;

		_tcscpy_s(	sErrorOut,
					lDimErrorIn,
					_TEXT(""));
	}

	UNREFERENCED_PARAMETER(eStdinIn);
	UNREFERENCED_PARAMETER(eStdoutIn);
	UNREFERENCED_PARAMETER(lDimErrorIn);
	UNREFERENCED_PARAMETER(sErrorOut);

	// success
	bResult = TRUE;

	return(bResult);
}

//------------------------------------------------------------------------
#elif defined (PNDEV_OS_ADONIS)
//------------------------------------------------------------------------
BOOLEAN	fnDrvUtil_RegisterStdStreams(	const ePNDEV_STDIN	eStdinIn,
										const ePNDEV_STDOUT	eStdoutIn,
										const UINT32		lDimErrorIn,
										HANDLE*				pHandleStdinOut,
										HANDLE*				pHandleStdoutOut,
										PNDEV_CHAR*			sErrorOut)
{
BOOLEAN bResult			= FALSE;
UINT32	lResultTmp		= ADN_ERROR;

	// preset OutputParameter
	{
		*pHandleStdinOut	= NULL;
		*pHandleStdoutOut	= NULL;

		_tcscpy_s(	sErrorOut,
					lDimErrorIn,
					_TEXT(""));
	}

	if	( 	(eStdoutIn	== ePNDEV_STDOUT_INVALID)
		||  (eStdinIn	== ePNDEV_STDIN_INVALID))
		// no valid stdin or stdout type
	{
		// set ErrorString
		_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
		_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Invalid stdin/stdout item!"), _TRUNCATE);
	}
	else
	{
		if	(fnDrvUtil_InstallDriver(	eStdinIn,
										eStdoutIn,
										_countof(sErrorOut),
										pHandleStdinOut,
										pHandleStdoutOut,
										sErrorOut))
			// installing driver ok
		{
			if ((int32_t) (*pHandleStdinOut) == (int32_t) (*pHandleStdoutOut))
				// stdin/stdout were configured for using the same driver as stdio
			{
				// register stdio
				lResultTmp = adn_std_io_register((int32_t) (*pHandleStdoutOut));

				if	(lResultTmp == ADN_ERROR)
					// error
				{
					// set ErrorString
					_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
					_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Error at registering stdin/stdout!"), _TRUNCATE);
				}
				else
				{
					// success
					bResult = TRUE;
				}
			}
			else
			{
				// register stdout
				lResultTmp = adn_std_out_register((int32_t) (*pHandleStdoutOut));

				if	(lResultTmp == ADN_ERROR)
					// error
				{
					// set ErrorString
					_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
					_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Error at registering stdout!"), _TRUNCATE);
				}
				else
				{
					// register stdin
					lResultTmp = adn_std_err_register((int32_t) (*pHandleStdoutOut));

					if	(lResultTmp == ADN_ERROR)
						// error
					{
						// set ErrorString
						_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
						_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Error at registering stderr!"), _TRUNCATE);
					}
					else
					{
						// register stdin
						lResultTmp = adn_std_in_register((int32_t) (*pHandleStdinOut));

						if	(lResultTmp == ADN_ERROR)
							// error
						{
							// set ErrorString
							_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
							_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Error at registering stdin!"), _TRUNCATE);
						}
						else
						{
							// success
							bResult = TRUE;
						}
					}
				}
			}
		}
	}

	return(bResult);
}
//------------------------------------------------------------------------
#elif defined (PNDEV_OS_UNKNOWN)
//------------------------------------------------------------------------
#endif

//************************************************************************
//  D e s c r i p t i o n :
//
//	install and open drivers (VGA, RS232A, RS232B)
//************************************************************************

//------------------------------------------------------------------------
#if defined (PNDEV_OS_WIN)
//------------------------------------------------------------------------

//------------------------------------------------------------------------
#elif defined (PNDEV_OS_ADONIS)
//------------------------------------------------------------------------
BOOLEAN	fnDrvUtil_InstallDriver(	const ePNDEV_STDIN	eStdinIn,
									const ePNDEV_STDOUT	eStdoutIn,
									const UINT32		lDimErrorIn,
									HANDLE*				pHandleStdinOut,
									HANDLE*				pHandleStdoutOut,
									PNDEV_CHAR*			sErrorOut)
{
BOOLEAN bResult			= FALSE;
BOOLEAN	bStdInInstalled	= FALSE;
int32_t	lResultTmp		= ADN_OK;
UINT32	lHandleStdIn	= -1;
UINT32	lHandleStdOut	= -1;
char*	sDriverPath		= NULL;

	// stdin/stdout/stderr separately
	{
		switch  (eStdoutIn)
				// StdOutType
		{
			case ePNDEV_STDOUT_SCREEN:
			{
				// install driver
				lResultTmp = vga_drv_install();

				// set driver path
				sDriverPath = VGA_DRV_NAME;

				break;
			}
			case ePNDEV_STDOUT_RS232A:
			{
				// install driver
				lResultTmp = rs232_num_drv_install(RS232A);

				// set driver path
				sDriverPath = RS232A_NAME;

				break;
			}
			case ePNDEV_STDOUT_RS232B:
			{
				// install driver
				lResultTmp = rs232_num_drv_install(RS232B);

				// set driver path
				sDriverPath = RS232B_NAME;

				break;
			}
			case ePNDEV_STDOUT_VCON:
			{
				// install driver
				lResultTmp = vcon_drv_install();

				// set driver path
				sDriverPath = VCON_DEVICE_NAME;

				break;
			}
		   default:
		   {
			   // set ErrorString
			   _tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
			   _tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Invalid stdout item!"), _TRUNCATE);

			   break;
		   }
		}

		if	(lResultTmp == ADN_ERROR)
			// error
		{
			// set ErrorString
			_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
			_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Error at installing driver for stdout!"), _TRUNCATE);
		}
		else
		{
			// open corresponding driver
			lHandleStdOut = open(	sDriverPath,
									O_CREAT | O_RDWR | V_STD);

			if  (lHandleStdOut == ADN_ERROR)
				// error
			{
				// set ErrorString
				_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
				_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Error at opening driver for stdout!"), _TRUNCATE);
			}
			else
			{
				// Note:
				//	- terminal connection via com port necessary
				//	- configuration: baud rate = 115200, data = 8 bit, stop = 1 bit

				// continue on same procedure for stdin

				switch  (eStdinIn)
						// StdinType
				{
					case ePNDEV_STDIN_KEYBOARD:
					{
						// install driver
						lResultTmp = kb_drv_install();

						// set driver path
						sDriverPath = KB_DRV_NAME;

						break;
					}
					case ePNDEV_STDIN_RS232A:
					{
						if (0 == _tcscmp(sDriverPath,RS232A_NAME))
						{
							// stdin driver already installed
							bStdInInstalled = TRUE;
						}
						else
						{
							// install driver
							lResultTmp = rs232_num_drv_install(RS232A);

							// set driver path
							sDriverPath = RS232A_NAME;
						}

						break;
					}
					case ePNDEV_STDIN_RS232B:
					{
						if (0 == _tcscmp(sDriverPath, RS232B_NAME))
						{
							// stdin driver already installed
							bStdInInstalled = TRUE;
						}
						else
						{
							// install driver
							lResultTmp = rs232_num_drv_install(RS232B);

							// set driver path
							sDriverPath = RS232B_NAME;
						}

						break;
					}
					case ePNDEV_STDIN_VCON:
					{
						if (0 == _tcscmp(sDriverPath, VCON_DEVICE_NAME))
						{
							// stdin driver already installed
							bStdInInstalled = TRUE;
						}
						else
						{
							// install driver
							lResultTmp = vcon_drv_install();

							// set driver path
							sDriverPath = VCON_DEVICE_NAME;
						}

						break;
					}
				   default:
				   {
					   // set ErrorString
					   _tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
					   _tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Invalid stdin item!"), _TRUNCATE);

					   break;
				   }
				}

				if	(bStdInInstalled)
					// stdin driver already installed
				{
					// success
					bResult = TRUE;

					// no handle for stdin necessary
					lHandleStdIn = lHandleStdOut;
				}
				else
				{
					if	(lResultTmp == ADN_ERROR)
						// error
					{
						// set ErrorString
						_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
						_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Error at installing driver for stdin!"), _TRUNCATE);
					}
					else
					{
						// open driver
						lHandleStdIn = open(sDriverPath,
											O_CREAT | O_RDWR | V_STD);

						if  ((lHandleStdIn 	== ADN_ERROR))
							// error
						{
							// set ErrorString
							_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
							_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Error at opening or installing driver for stdin!"), _TRUNCATE);
						}
						else
						{
							// success
							bResult = TRUE;
						}
					}
				}
			}
		}
	}

	// return
	*pHandleStdinOut	= (HANDLE*) lHandleStdIn;
	*pHandleStdoutOut	= (HANDLE*) lHandleStdOut;

	return(bResult);

}
//------------------------------------------------------------------------
#elif defined (PNDEV_OS_LINUX)
//------------------------------------------------------------------------

//------------------------------------------------------------------------
#elif defined (PNDEV_OS_UNKNOWN)
//------------------------------------------------------------------------
#endif

//************************************************************************
//  D e s c r i p t i o n :
//
//  check if PnDevDriver is installed
//************************************************************************

//------------------------------------------------------------------------
#if defined (PNDEV_OS_WIN)
//------------------------------------------------------------------------
BOOLEAN fnDrvUtil_CheckInstalledDriver(	PNDEV_CHAR*		sSysFileNameIn,
										const UINT32	lDimErrorIn,
										PNDEV_CHAR*		sErrorOut)
{
BOOLEAN bResult					= FALSE;
_TCHAR	sPathDriver[MAX_PATH]	= {0};

	if	(!GetSystemDirectory(	sPathDriver,
								_countof(sPathDriver)))
		// error at getting SystemDirectory
	{
		// set ErrorString
		_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
		_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Error at GetSystemDirectory()!"), _TRUNCATE);
	}
	else
	{
	_TCHAR	sPathSystem[MAX_PATH] = {0};

		// copy SystemPath
		_tcscpy_s(	sPathSystem, _countof(sPathSystem),sPathDriver);

		// append DriverDirectory
		_tcsncat_s(	sPathDriver, _countof(sPathDriver),	_TEXT("\\drivers\\"), _TRUNCATE);

		// append SysFileName
		_tcsncat_s(	sPathDriver, _countof(sPathDriver), sSysFileNameIn, _TRUNCATE);

		if (!PathFileExistsW(sPathDriver))
			// error at checking
		{
			#if (PNDEV_PLATFORM == PNDEV_UM_PLATFORM_32)
				// try again for 32BitApplications on 64BitMachine

				// get SystemPath
				_tcscpy_s(	sPathDriver, _countof(sPathDriver), sPathSystem);

				// append DriverDirectory
				_tcsncat_s(	sPathDriver, _countof(sPathDriver), _TEXT("\\..\\Sysnative\\drivers\\"), _TRUNCATE);

				// append SysFileName
				_tcsncat_s(	sPathDriver, _countof(sPathDriver), sSysFileNameIn, _TRUNCATE);

				if (PathFileExistsW(sPathDriver))
					// error at checking
				{
					// success
					bResult = TRUE;
				}

			#endif

			if	(!bResult)
				// set ErrorString
			{
				_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
				_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Error at PathFileExists()! File PnDev_Driver.sys was not found!"), _TRUNCATE);
			}
		}
		else
		{
			// success
			bResult = TRUE;
		}
	}

	return(bResult);
}
//------------------------------------------------------------------------
#else
//------------------------------------------------------------------------
BOOLEAN fnDrvUtil_CheckInstalledDriver(	PNDEV_CHAR*		sSysFileNameIn,
										const UINT32	lDimErrorIn,
										PNDEV_CHAR*		sErrorOut)
{
BOOLEAN bResult = TRUE;

	UNREFERENCED_PARAMETER(sSysFileNameIn);
	UNREFERENCED_PARAMETER(lDimErrorIn);
	UNREFERENCED_PARAMETER(sErrorOut);

	return(bResult);
}
#endif

//************************************************************************
//  D e s c r i p t i o n :
//
//	unregister StdStreams (stdin, stdout, stderr)
//************************************************************************

//------------------------------------------------------------------------
#if defined (PNDEV_OS_WIN) || defined (PNDEV_OS_LINUX)
//------------------------------------------------------------------------
BOOLEAN fnDrvUtil_UnregisterStdStreams(	const HANDLE	hStdinIn,
										const HANDLE	hStdoutIn,
										const UINT32	lDimErrorIn,
										PNDEV_CHAR*		sErrorOut)
{
BOOLEAN bResult = FALSE;

	UNREFERENCED_PARAMETER(hStdinIn);
	UNREFERENCED_PARAMETER(hStdoutIn);
	UNREFERENCED_PARAMETER(lDimErrorIn);
	UNREFERENCED_PARAMETER(sErrorOut);

	// preset OutputParameter
	_tcscpy_s(	sErrorOut,
				lDimErrorIn,
				_TEXT(""));

	bResult = TRUE;

	return(bResult);
}

//------------------------------------------------------------------------
#elif defined (PNDEV_OS_ADONIS)
//------------------------------------------------------------------------
BOOLEAN fnDrvUtil_UnregisterStdStreams(	const HANDLE	hStdinIn,
										const HANDLE	hStdoutIn,
										const UINT32	lDimErrorIn,
										PNDEV_CHAR*		sErrorOut)
{
BOOLEAN bResult		= FALSE;
UINT32	lResultTmp	= ADN_ERROR;

	if ((int32_t) hStdinIn == (int32_t) hStdoutIn)
		// stdin/stdout were configured for using the same driver as stdio
	{
		// unregister stdio
		lResultTmp = adn_std_io_unregister();

		if	(lResultTmp == ADN_ERROR)
			// error
		{
			// set ErrorString
			_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
			_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Error at unregistering stdin/stdout!"), _TRUNCATE);
		}
		else
		{
			// close driver
			lResultTmp = close((int32_t) hStdoutIn);

			if	(lResultTmp == ADN_ERROR)
				// error
			{
				// set ErrorString
				_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
				_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Error at closing stdin/stdout driver!"), _TRUNCATE);
			}
			else
			{
				// success
				bResult = TRUE;
			}
		}
	}
	else
	{
		// unregister stdout
		lResultTmp = adn_std_out_unregister();

		if	(lResultTmp == ADN_ERROR)
			// error
		{
			// set ErrorString
			_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
			_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Error at unregistering stdout!"), _TRUNCATE);
		}
		else
		{
			// unregister stdin
			lResultTmp = adn_std_in_unregister();

			if	(lResultTmp == ADN_ERROR)
				// error
			{
				// set ErrorString
				_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
				_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Error at unregistering stdin!"), _TRUNCATE);
			}
		}

		if	(lResultTmp != ADN_ERROR)
			// error
		{
			// close stdin driver
			lResultTmp = close((int32_t) hStdinIn);

			if	(lResultTmp == ADN_ERROR)
				// error
			{
				// set ErrorString
				_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
				_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Error at closing stdin driver!"), _TRUNCATE);
			}
			else
			{
				// close stdout driver
				lResultTmp = close((int32_t) hStdoutIn);

				if	(lResultTmp == ADN_ERROR)
					// error
				{
					// set ErrorString
					_tcscpy_s(	sErrorOut, lDimErrorIn, _TEXT(__FUNCTION__));
					_tcsncat_s(	sErrorOut, lDimErrorIn, _TEXT("(): Error at closing stdout driver!"), _TRUNCATE);
				}
				else
				{
					// success
					bResult = TRUE;
				}
			}
		}
	}

	return(bResult);
}

//------------------------------------------------------------------------
#elif defined (PNDEV_OS_UNKNOWN)
//------------------------------------------------------------------------
#endif


